body {
	padding: 0;
	margin: 0;
	display: flex;
	justify-content: center;
	align-items: center;
	height: 100vh;
	background: darkolivegreen;
}

.container {
	width: 360px;
	height: 360px;
	border: 1px solid red;
}

.container::after {
	counter-reset: t var(--t);
	content: counter(t);
}

.vec {
	margin: 0;
	padding: 0;
}

@property --t {
	syntax: "<integer>";
	initial-value: 0;
	inherits: true
}

@keyframes tick {
	from {
		--t: 0
	}

	to {
		--t: 86400000
	}
}

:root {
	/* number of ms in 24h */
	animation: tick 86400000ms linear infinite;
	--ix1: 180;
	--iy1: 180;
	--ix2: 270;
	--iy2: 270;
	--line-width: 3;
}

/* setup */
.vec {
	position: relative;

	/* convert to radians */
	--rad: calc(var(--t) * 0.0174533 / 65);

	/* rotation matrix */
	--xx: calc(      cos(var(--rad)));
	--xy: calc( -1 * sin(var(--rad))); /* css calc() doesn't like unary minus :^) */
	--yx: calc(      sin(var(--rad)));
	--yy: calc(      cos(var(--rad)));
}

/* NOTE: This is more proof of concept than anything, transform is probably
* usable and surely more performant, but this was very interesting to figure
* out and it's good to know that this is possible in case transform is too
* limited for the visualiation */

/* size and translation */
.vec {
	--x1: var(--ix1);
	--y1: var(--iy1);

	/* NOTE: you have to define the vector's x and y relative to the point you want to rotate around
	* because by just rotating the vector, the origin of the vector will be the origin of the coordinate system
	* and not the point you want to rotate around */

	/* point of rotation */
	--ox: var(--ix1);
	--oy: var(--iy1);

	/* local x and y (relative to the point of rotation) */
	--vx2: calc(
		var(--ix2) - var(--ox)
	);
	--vy2: calc(
		var(--iy2) - var(--oy)
	);

	/* NOTE: cascading is weird with these vars so be careful to make unique names
*
	/* rotated x and y */
	--rx2: calc(
		var(--xx) * var(--vx2) + var(--xy) * var(--vy2)
	);
	--ry2: calc(
		var(--yx) * var(--vx2) + var(--yy) * var(--vy2)
	);

	/* global x and y (relative to the origin) */
	--x2: calc(
		var(--rx2) + var(--ox)
	);
	--y2: calc(
		var(--ry2) + var(--oy)
	);

	--w: calc(
		max(var(--x2) - var(--x1), var(--x1) - var(--x2))
	);

	--h: calc(
		max(var(--y2) - var(--y1), var(--y1) - var(--y2))
	);

	width: calc(
		var(--w) * 1px
	);
	height: calc(
		var(--h) * 1px
	);

	left: calc(
		min( var(--x1), var(--x2) ) * 1px
	);
	top:  calc(
		min( var(--y1), var(--y2) ) * 1px
	);
}
.vec {

	background: gray;
	--l: var(--line-width);

	--len: 90;

	/* initial arrow positions */
	--vpx: 0;
	--vpy: var(--l);

	--vqx: calc(var(--len) - var(--l));
	--vqy: var(--len);

	--vrx: var(--len);
	--vry: calc(var(--len) - var(--l));

	--vsx: var(--l);
	--vsy: 0;

	/* rotate x,y around local origin */
	--rpx: calc(
		var(--xx) * var(--vpx) + var(--xy) * var(--vpy)
	);
	--rpy: calc(
		var(--yx) * var(--vpx) + var(--yy) * var(--vpy)
	);

	--rqx: calc(
		var(--xx) * var(--vqx) + var(--xy) * var(--vqy)
	);
	--rqy: calc(
		var(--yx) * var(--vqx) + var(--yy) * var(--vqy)
	);

	--rrx: calc(
		var(--xx) * var(--vrx) + var(--xy) * var(--vry)
	);
	--rry: calc(
		var(--yx) * var(--vrx) + var(--yy) * var(--vry)
	);

	--rsx: calc(
		var(--xx) * var(--vsx) + var(--xy) * var(--vsy)
	);
	--rsy: calc(
		var(--yx) * var(--vsx) + var(--yy) * var(--vsy)
	);

	/* NOTE: to make clip path thing work you have to find the most
	* negative x and y so you can find the offset by how much to move the whole
	* thing to keep it in positive space as it rotates since clip path only
	* wants *local* *positive* values scaled to its length (using % might also work
	* with this offset adjustment stuff)
	* */

	/* smallest x */
	--smx: calc(min(var(--rpx), var(--rqx), var(--rrx), var(--rsx)));

	/* smallest y */
	--smy: calc(min(var(--rpy), var(--rqy), var(--rry), var(--rsy)));


	--offx: calc(min(var(--smx), 0) * -1);
	--offy: calc(min(var(--smy), 0) * -1);

	--px: calc(
		var(--rpx) + var(--offx)
	);
	--py: calc(
		var(--rpy) + var(--offy)
	);

	--qx: calc(
		var(--rqx) + var(--offx)
	);
	--qy: calc(
		var(--rqy) + var(--offy)
	);

	--rx: calc(
		var(--rrx) + var(--offx)
	);
	--ry: calc(
		var(--rry) + var(--offy)
	);

	--sx: calc(
		var(--rsx) + var(--offx)
	);
	--sy: calc(
		var(--rsy) + var(--offy)
	);

	clip-path: polygon(
		calc(var(--px) * 1px) calc(var(--py) * 1px),
		calc(var(--qx) * 1px) calc(var(--qy) * 1px),
		calc(var(--rx) * 1px) calc(var(--ry) * 1px),
		calc(var(--sx) * 1px) calc(var(--sy) * 1px)
	);
}

/**/
/* .vec .debug { */
/* 	--debug: var(--offy); */
/* 	border: calc(var(--debug) * 1px) solid red; */
/* 	font-size: 2em; */
/* 	color: white; */
/* 	position: absolute; */
/* 	left: calc(var(--ww) * 1px); */
/* 	top: calc(var(--hh) * 1px); */
/* } */
/**/
