@property --t {
	syntax: "<integer>";
	initial-value: 0;
	inherits: true
}

@keyframes tick {
	from {
		--t: 0
	}

	to {
		--t: 86400000
	}
}

:root {
	/* number of ms in 24h */
	animation: tick 86400000ms linear infinite;
	--ix1: 180;
	--iy1: 180;
	--ix2: 270;
	--iy2: 270;
	--line-width: 3;
}

/* rotation matrix */
:root {
	/* convert to radians */
	--rad: calc(var(--t) * 0.0174533 / 25);

	/* rotation matrix */
	--xx: calc(      cos(var(--rad)));
	--xy: calc( -1 * sin(var(--rad))); /* css calc() doesn't like unary minus :^) */
	--yx: calc(      sin(var(--rad)));
	--yy: calc(      cos(var(--rad)));
}

/* TODO: you might be able to have a "canvas" element in which you have the
* clippath thing and you keep adding points to it as you rotate the vector,
* and you end up "tracing" the points as they change

/* NOTE: This is more proof of concept than anything, transform is probably
* usable and surely more performant, but this was very interesting to figure
* out and it's good to know that this is possible in case transform is too
* limited for the visualiation */

/* size and translation */
:root {
	--x1: var(--ix1);
	--y1: var(--iy1);

	/* NOTE: you have to define the vector's x and y relative to the point you want to rotate around
	* because by just rotating the vector, the origin of the vector will be the origin of the coordinate system
	* and not the point you want to rotate around */

	/* point of rotation */
	--ox: var(--ix1);
	--oy: var(--iy1);

	/* local x and y (relative to the point of rotation) */
	--vx2: calc(
		var(--ix2) - var(--ox)
	);
	--vy2: calc(
		var(--iy2) - var(--oy)
	);

	/* rotated x and y */
	--rx2: calc(
		var(--xx) * var(--vx2) + var(--xy) * var(--vy2)
	);
	--ry2: calc(
		var(--yx) * var(--vx2) + var(--yy) * var(--vy2)
	);

	/* global x and y (relative to the origin) */
	--x2: calc(
		var(--rx2) + var(--ox)
	);
	--y2: calc(
		var(--ry2) + var(--oy)
	);

	--w: calc(
		max(var(--x2) - var(--x1), var(--x1) - var(--x2))
	);

	--h: calc(
		max(var(--y2) - var(--y1), var(--y1) - var(--y2))
	);
}


/* vec rectangle points computations */
:root {
	--l: var(--line-width);

	/* TODO: figure out why this works when len is 90 but not when its 127
	* (127 is the length of the initial vector) maybe something to do with
	* width? because width is 90... */
	--len: calc(
		sqrt(
			pow(var(--ix1) - var(--ix2), 2) + pow(var(--iy1) - var(--iy2), 2)
		)
	);
	--len: 127;
	--len: 90;

	/* initial arrow positions */
	--vpx: 0;
	--vpy: var(--l);

	--vqx: calc(var(--len) - var(--l));
	--vqy: var(--len);

	--vrx: var(--len);
	--vry: calc(var(--len) - var(--l));

	--vsx: var(--l);
	--vsy: 0;

	/* rotate x,y around local origin */
	--rpx: calc(
		var(--xx) * var(--vpx) + var(--xy) * var(--vpy)
	);
	--rpy: calc(
		var(--yx) * var(--vpx) + var(--yy) * var(--vpy)
	);

	--rqx: calc(
		var(--xx) * var(--vqx) + var(--xy) * var(--vqy)
	);
	--rqy: calc(
		var(--yx) * var(--vqx) + var(--yy) * var(--vqy)
	);

	--rrx: calc(
		var(--xx) * var(--vrx) + var(--xy) * var(--vry)
	);
	--rry: calc(
		var(--yx) * var(--vrx) + var(--yy) * var(--vry)
	);

	--rsx: calc(
		var(--xx) * var(--vsx) + var(--xy) * var(--vsy)
	);
	--rsy: calc(
		var(--yx) * var(--vsx) + var(--yy) * var(--vsy)
	);

	/* NOTE: to make clip path thing work you have to find the most
	* negative x and y so you can find the offset by how much to move the whole
	* thing to keep it in positive space as it rotates since clip path only
	* wants *local* *positive* values scaled to its length (using % might also work
	* with this offset adjustment stuff)
	* */

	/* smallest x */
	--smx: calc(min(var(--rpx), var(--rqx), var(--rrx), var(--rsx)));

	/* smallest y */
	--smy: calc(min(var(--rpy), var(--rqy), var(--rry), var(--rsy)));


	--offx: calc(min(var(--smx), 0) * -1);
	--offy: calc(min(var(--smy), 0) * -1);

	--px: calc(
		var(--rpx) + var(--offx)
	);
	--py: calc(
		var(--rpy) + var(--offy)
	);

	--qx: calc(
		var(--rqx) + var(--offx)
	);
	--qy: calc(
		var(--rqy) + var(--offy)
	);

	--rx: calc(
		var(--rrx) + var(--offx)
	);
	--ry: calc(
		var(--rry) + var(--offy)
	);

	--sx: calc(
		var(--rsx) + var(--offx)
	);
	--sy: calc(
		var(--rsy) + var(--offy)
	);
}

/* canvas point computations */
:root {
	--point-size: 10;
	--point-x: 30;
	--point-x: var(--x2);
	--point-y: var(--y2);

	--ppx: var(--point-x);
	--ppy: var(--point-y);

	--pqx: var(--point-x);
	--pqy: calc(var(--point-y) + var(--point-size));

	--prx: calc(var(--point-x) + var(--point-size));
	--pry: calc(var(--point-y) + var(--point-size));

	--psx: calc(var(--point-x) + var(--point-size));
	--psy: var(--point-y);
}
