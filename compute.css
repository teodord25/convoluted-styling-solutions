@property --t {
	syntax: "<integer>";
	initial-value: 0;
	inherits: true
}

@keyframes tick {
	from {
		--t: 0
	}

	to {
		--t: 86400000
	}
}

:root {
	/* number of ms in 24h */
	animation: tick 86400000ms linear infinite;
	--ix1: 180;
	--iy1: 180;
	--ix2: 270;
	--iy2: 180;
	--line-width: 5;
}

/* rotation matrix */
:root {
	/* 1 second = pi/4 radians */
	--rad: calc((var(--t) / 1000) * (.25 * 3.1415));

	/* rotation matrix */
	--xx: calc(      cos(var(--rad)));
	--xy: calc( -1 * sin(var(--rad))); /* css calc() doesn't like unary minus :^) */
	--yx: calc(      sin(var(--rad)));
	--yy: calc(      cos(var(--rad)));
}

/* TODO: you might be able to have a "canvas" element in which you have the
* clippath thing and you keep adding points to it as you rotate the vector,
* and you end up "tracing" the points as they change

/* NOTE: This is more proof of concept than anything, transform is probably
* usable and surely more performant, but this was very interesting to figure
* out and it's good to know that this is possible in case transform is too
* limited for the visualiation */

/* size and translation */
:root {
	--x1: var(--ix1);
	--y1: var(--iy1);

	/* NOTE: you have to define the vector's x and y relative to the point you want to rotate around
	* because by just rotating the vector, the origin of the vector will be the origin of the coordinate system
	* and not the point you want to rotate around */

	/* point of rotation */
	--ox: var(--ix1);
	--oy: var(--iy1);

	/* local x and y (relative to the point of rotation) */
	--vx2: calc(
		var(--ix2) - var(--ox)
	);
	--vy2: calc(
		var(--iy2) - var(--oy)
	);

	/* rotated x and y */
	--rx2: calc(
		var(--xx) * var(--vx2) + var(--xy) * var(--vy2)
	);
	--ry2: calc(
		var(--yx) * var(--vx2) + var(--yy) * var(--vy2)
	);

	/* global x and y (relative to the origin) */
	--x2: calc(
		var(--rx2) + var(--ox)
	);
	--y2: calc(
		var(--ry2) + var(--oy)
	);

	--w: calc(
		max(var(--x2) - var(--x1), var(--x1) - var(--x2))
	);

	--h: calc(
		max(var(--y2) - var(--y1), var(--y1) - var(--y2))
	);

	--max-width: calc(
		max(var(--ix2) - var(--ix1), var(--ix1) - var(--ix2)) * 2
	);

	--max-height: calc(
		max(var(--ix2) - var(--ix1), var(--ix1) - var(--ix2)) * 2
	);
}


:root {
/***********************************************************
*          o                                               *
*          oo                                              *
*          o o                                             *
*ooooooooooo  o                                            *
*o         o   o                                           *
*ooooooooooo  o                                            *
*          o o                                             *
*          oo                                              *
*          o                                               *
***********************************************************/

	--arrow-x1: 0;
	--arrow-y1: 3;

	--arrow-x2: 0;
	--arrow-y2: 5;

	--arrow-x3: 10;
	--arrow-y3: 5;

	--arrow-x4: 10;
	--arrow-y4: 8;

	--arrow-x5: 14;
	--arrow-y5: 4;

	--arrow-x6: 10;
	--arrow-y6: 0;

	--arrow-x7: 10;
	--arrow-y7: 3;
}

/* canvas point computations */
:root {
	--point-size: 10;
	--point-x: 30;
	--point-x: var(--x2);
	--point-y: var(--y2);

	--ppx: var(--point-x);
	--ppy: var(--point-y);

	--pqx: var(--point-x);
	--pqy: calc(var(--point-y) + var(--point-size));

	--prx: calc(var(--point-x) + var(--point-size));
	--pry: calc(var(--point-y) + var(--point-size));

	--psx: calc(var(--point-x) + var(--point-size));
	--psy: var(--point-y);
}
