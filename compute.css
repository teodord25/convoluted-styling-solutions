@property --t {
	syntax: "<integer>";
	initial-value: 0;
	inherits: true
}

@keyframes tick {
	from {
		--t: 0
	}

	to {
		--t: 86400000
	}
}


.counter::after {
	counter-reset: t var(--t);
	content: counter(t);
}

:root {
	animation: tick 86400000ms linear infinite;

	--origin-offset-x: 180;
	--origin-offset-y: 180;
}

/* NOTE: you can have as many frequencies as you have points because this is a DFT */
:root {
	--p1x: -100;
	--p1y: 0;

	--p2x: 0;
	--p2y: 100;

	--p3x: 200;
	--p3y: 100;

	--p4x: 100;
	--p4y: 0;

	--phase: calc(2 * pi * var(--t) / 5000);
}


/* I have no idea why using both sin and cos when calculating the coefficients real and imaginary parts  works 
* but separating them into x and y doesn't. */
:root {
	--q00: 0;
	--const00: calc(var(--q00) * 2 * pi / 4);

	--a00: calc(
		1 / 4 * (
			var(--p1x) +
			var(--p2x) +
			var(--p3x) +
			var(--p4x)
		)
	);

	--b00: calc(
		1 / 4 * (
			var(--p1y) +
			var(--p2y) +
			var(--p3y) +
			var(--p4y)
		)
	);

	--x00: calc(
		var(--a00) * cos(var(--const00) * var(--phase)) - var(--b00) * sin(var(--const00) * var(--phase))
	);

	--y00: calc(
		var(--a00) * sin(var(--const00) * var(--phase)) + var(--b00) * cos(var(--const00) * var(--phase))
	);
}

:root {
	--q01: 1;
	--const01: calc(var(--q01) * 2 * pi / 4);

	--a01: calc(
		1 / 4 * (
			var(--p1x) * (cos(var(--const01) * 0) + sin(var(--const01) * 0)) +
			var(--p2x) * (cos(var(--const01) * 1) + sin(var(--const01) * 1)) +
			var(--p3x) * (cos(var(--const01) * 2) + sin(var(--const01) * 2)) +
			var(--p4x) * (cos(var(--const01) * 3) + sin(var(--const01) * 3))
		)
	);

	--b01: calc(
		1 / 4 * (
			var(--p1y) * (cos(var(--const01) * 0) - sin(var(--const01) * 0)) +
			var(--p2y) * (cos(var(--const01) * 1) - sin(var(--const01) * 1)) +
			var(--p3y) * (cos(var(--const01) * 2) - sin(var(--const01) * 2)) +
			var(--p4y) * (cos(var(--const01) * 3) - sin(var(--const01) * 3))
		)
	);
	--x01: calc(
		var(--a01) * cos(var(--const01) * var(--phase)) - var(--b01) * sin(var(--const01) * var(--phase))
	);

	--y01: calc(
		var(--a01) * sin(var(--const01) * var(--phase)) + var(--b01) * cos(var(--const01) * var(--phase))
	);
}
:root {
	--q-1: -1; /* Changed from 1 to -1 for -1st harmonic */
	--const-1: calc(var(--q-1) * 2 * pi / 4);

	--a-1: calc(
		1 / 4 * (
			var(--p1x) * (cos(var(--const-1) * 0) + sin(var(--const-1) * 0)) +
			var(--p2x) * (cos(var(--const-1) * 1) + sin(var(--const-1) * 1)) +
			var(--p3x) * (cos(var(--const-1) * 2) + sin(var(--const-1) * 2)) +
			var(--p4x) * (cos(var(--const-1) * 3) + sin(var(--const-1) * 3))
		)
	);

	--b-1: calc(
		1 / 4 * (
			var(--p1y) * (cos(var(--const-1) * 0) - sin(var(--const-1) * 0)) +
			var(--p2y) * (cos(var(--const-1) * 1) - sin(var(--const-1) * 1)) +
			var(--p3y) * (cos(var(--const-1) * 2) - sin(var(--const-1) * 2)) +
			var(--p4y) * (cos(var(--const-1) * 3) - sin(var(--const-1) * 3))
		)
	);

	--x-1: calc(
		var(--a-1) * cos(var(--const-1) * var(--phase)) - var(--b-1) * sin(var(--const-1) * var(--phase))
	);

	--y-1: calc(
		var(--a-1) * sin(var(--const-1) * var(--phase)) + var(--b-1) * cos(var(--const-1) * var(--phase))
	);
}

:root {
	--q02: 2;
	--const02: calc(var(--q02) * 2 * pi / 4);

	--a02: calc(
		1 / 4 * (
			var(--p1x) * (cos(var(--const02) * 0) + sin(var(--const02) * 0)) +
			var(--p2x) * (cos(var(--const02) * 1) + sin(var(--const02) * 1)) +
			var(--p3x) * (cos(var(--const02) * 2) + sin(var(--const02) * 2)) +
			var(--p4x) * (cos(var(--const02) * 3) + sin(var(--const02) * 3))
		)
	);

	--b02: calc(
		1 / 4 * (
			var(--p1y) * (cos(var(--const02) * 0) - sin(var(--const02) * 0)) +
			var(--p2y) * (cos(var(--const02) * 1) - sin(var(--const02) * 1)) +
			var(--p3y) * (cos(var(--const02) * 2) - sin(var(--const02) * 2)) +
			var(--p4y) * (cos(var(--const02) * 3) - sin(var(--const02) * 3))
		)
	);

	--x02: calc(
		var(--a02) * cos(var(--const02) * var(--phase)) - var(--b02) * sin(var(--const02) * var(--phase))
	);

	--y02: calc(
		var(--a02) * sin(var(--const02) * var(--phase)) + var(--b02) * cos(var(--const02) * var(--phase))
	);
}
