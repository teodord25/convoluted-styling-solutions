@property --t {
	syntax: "<integer>";
	initial-value: 0;
	inherits: true
}

@keyframes tick {
	from {
		--t: 0
	}

	to {
		--t: 86400000
	}
}


.counter::after {
	counter-reset: t var(--t);
	content: counter(t);
}

:root {
	animation: tick 86400000ms linear infinite;
	--i1x1: 180;
	--i1y1: 180;
	--i1x2: 270;
	--i1y2: 180;
	--line-width: 5;
}

/* rotation matrix */
:root {
	/* 1 second = pi/4 radians */
	--rad: calc((var(--t) / 1000) * (.25 * 3.1415));

	/* rotation matrix */
	--xx: calc(      cos(var(--rad)));
	--xy: calc( -1 * sin(var(--rad))); /* css calc() doesn't like unary minus :^) */
	--yx: calc(      sin(var(--rad)));
	--yy: calc(      cos(var(--rad)));
}

/* TODO: you might be able to have a "canvas" element in which you have the
* clippath thing and you keep adding points to it as you rotate the vector,
* and you end up "tracing" the points as they change

/* NOTE: This is more proof of concept than anything, transform is probably
* usable and surely more performant, but this was very interesting to figure
* out and it's good to know that this is possible in case transform is too
* limited for the visualiation */

/* size and translation */
:root {
	--x1: var(--i1x1);
	--y1: var(--i1y1);

	/* NOTE: you have to define the vector's x and y relative to the point you want to rotate around
	* because by just rotating the vector, the origin of the vector will be the origin of the coordinate system
	* and not the point you want to rotate around */

	/* point of rotation */
	--ox: var(--i1x1);
	--oy: var(--i1y1);

	/* local x and y (relative to the point of rotation) */
	--vx2: calc(
		var(--i1x2) - var(--ox)
	);
	--vy2: calc(
		var(--i1y2) - var(--oy)
	);

	/* rotated x and y */
	--rx2: calc(
		var(--xx) * var(--vx2) + var(--xy) * var(--vy2)
	);
	--ry2: calc(
		var(--yx) * var(--vx2) + var(--yy) * var(--vy2)
	);

	/* global x and y (relative to the origin) */
	--x2: calc(
		var(--rx2) + var(--ox)
	);
	--y2: calc(
		var(--ry2) + var(--oy)
	);

	--w: calc(
		max(var(--x2) - var(--x1), var(--x1) - var(--x2))
	);

	--h: calc(
		max(var(--y2) - var(--y1), var(--y1) - var(--y2))
	);

	--max-width: calc(
		max(var(--i1x2) - var(--i1x1), var(--i1x1) - var(--i1x2)) * 2
	);

	--max-height: calc(
		max(var(--i1x2) - var(--i1x1), var(--i1x1) - var(--i1x2)) * 2
	);
}


:root {
	--arrow-x1: 0;
	--arrow-y1: 10;

	--arrow-x2: 80;
	--arrow-y2: 90;

	--arrow-x3: 70;
	--arrow-y3: 100;

	--arrow-x4: 100;
	--arrow-y4: 100;

	--arrow-x5: 100;
	--arrow-y5: 70;

	--arrow-x6: 90;
	--arrow-y6: 80;

	--arrow-x7: 10;
	--arrow-y7: 0;
}

/* second vector */
:root {
	--i2x1: calc(
		var(--x2)
	);
	--i2y1: calc(
		var(--y2)
	);
}

/* canvas point computations */
:root {
	--point-size: 10;
	--point-x: 30;

	/* NOTE: this can be used to debug values, it will draw a point at the specified x and y */
	--point-x: var(--i2x1);
	--point-y: var(--i2y1);

	--ppx: var(--point-x);
	--ppy: var(--point-y);

	--pqx: var(--point-x);
	--pqy: calc(var(--point-y) + var(--point-size));

	--prx: calc(var(--point-x) + var(--point-size));
	--pry: calc(var(--point-y) + var(--point-size));

	--psx: calc(var(--point-x) + var(--point-size));
	--psy: var(--point-y);
}
